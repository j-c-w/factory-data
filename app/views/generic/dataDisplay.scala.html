@(data: Array[backend.scala.query.ResultListObject[backend.scala.datatypes.LineListObject]], message: String, sessionId: String)

@import scala.util.Try
@import play.api.cache.Cache
@import play.api.Play.current

<!-- This chunk displays 100 rows worth of data, then
    puts the rest in cache and puts a link at the bottom
    to continue to the next page -->

@if(data.length > 100) {
    <!-- There are more elements after this, so
    leave the table as on-going -->
    <table class="dataTable">
} else {
    <!-- in this case, this is the last table, so
    end it -->
    <table class="lastDataTable">
}

    @for(dataItem <- Try(data.take(100)).getOrElse(data)) {
        <tr>@Html(dataItem.toHtml)</tr>
    }
</table>
<div class="next">
    @if(data.length > 100) {
        <!-- This is a 1 hour reset time -->
        @Cache.set(sessionId, data.drop(100), 3600)
        <a class="jscroll-next" href="@(routes.Application.moreData(sessionId))">next page</a>
    } else {
        <a class="jscroll-next" href="@routes.Application.endOfQuery()">next page</a>
    }

</div>

@if(false) {
    <!-- This is in here to quiet the compile warnings caused by
    an unclosed table tag-->
    </table>
}